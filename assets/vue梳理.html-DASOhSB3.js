import{_ as s,c as a,e,o as t}from"./app-Cqb5tvJn.js";const p={};function i(l,n){return t(),a("div",null,n[0]||(n[0]=[e(`<h1 id="vue梳理" tabindex="-1"><a class="header-anchor" href="#vue梳理"><span>vue梳理</span></a></h1><ol><li>执行 Vue.prototype._init 方法，初始化this.data，this.props， 执行钩子函数breforeCreate，observe data，代理data,props，执行钩子函数create</li><li>调用 mount方法，如果没有render方法，这里会生成render方法</li><li>mount 会调用 mountComponent, 创建一个watcher</li></ol><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line">  <span class="token function-variable function">updateComponent</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">    vm<span class="token punctuation">.</span><span class="token function">_update</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span><span class="token function">_render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> hydrating<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> updateComponent<span class="token punctuation">,</span> noop<span class="token punctuation">,</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">before</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>_isMounted<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">&#39;beforeUpdate&#39;</span><span class="token punctuation">)</span></span>
<span class="line">      <span class="token punctuation">}</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Watcher 在这里起到两个作用，一个是初始化的时候会执行回调函数， 另一个是当 vm 实例中的监测的数据发生变化的时候执行回调函数</p><h3 id="render" tabindex="-1"><a class="header-anchor" href="#render"><span>render</span></a></h3><ul><li>Vue 的 _render 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node</li><li>vm._render 最终是通过执行 createElement 方法并返回的是 vnode，它是一个虚拟 Node</li></ul><h3 id="update" tabindex="-1"><a class="header-anchor" href="#update"><span>update</span></a></h3><p>_update 的核心就是调用 vm.<strong>patch</strong> 方法</p><h3 id="首次渲染和更新" tabindex="-1"><a class="header-anchor" href="#首次渲染和更新"><span>首次渲染和更新</span></a></h3><ul><li><p>new Watcher 执行构造函数 -&gt; 执行get() -&gt; pushTarget(this)把watcher实例压栈，继续执行this.getter.call(vm, vm)，也就是执行updateComponent，vm._render() 会生成vnode，会对vm有数据访问，触发对象的getter，对象有__ob__代表是否有监听，对象的每一个值的getter都有个dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)，watcher中dep.addSub(this)，dep和watcher建立联系。执行get()最后会popTarget()</p></li><li><p>数据更新的时候，调用setter -&gt; dep.notify() -&gt; subs[i].update() 也就是watcher执行update() -&gt; queueWatcher(this) -&gt; watcher.run() -&gt; 执行get() -&gt; 执行updateComponent</p></li></ul><h3 id="编译" tabindex="-1"><a class="header-anchor" href="#编译"><span>编译</span></a></h3><ul><li>parse: 解析模板字符串生成AST树</li><li>optimize: 优化语法树,把一些 AST 节点优化成静态节点,可以在patch的过程跳过对他们的比对</li><li>codegen: AST树生成Vue的render渲染函数</li></ul><h3 id="nexttick" tabindex="-1"><a class="header-anchor" href="#nexttick"><span>nextTick</span></a></h3><ul><li>queueWatcher(this)实际上是用nextTick(flushSchedulerQueue),异步执行。</li><li>nextTick 是先用微任务，再用宏任务，if else else -&gt; promise.then -&gt; MutationObserver -&gt; setImmediate -&gt; setTimeout</li><li>callbacks数组添加回调函数，根据事件执行顺序（微任务，宏任务）执行callbacks里面的回调函数</li></ul><h3 id="vue-set" tabindex="-1"><a class="header-anchor" href="#vue-set"><span>Vue.set</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js"><pre><code><span class="line"><span class="token keyword">var</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span></span>
<span class="line">  <span class="token string">&#39;push&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string">&#39;pop&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string">&#39;shift&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string">&#39;unshift&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string">&#39;splice&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string">&#39;sort&#39;</span><span class="token punctuation">,</span></span>
<span class="line">  <span class="token string">&#39;reverse&#39;</span></span>
<span class="line"><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>数组重写，先执行原来的方法，push,unshift,splice这三个新增的方法拿到新增的对象，然后重新observe，并且ob.dep.notify()</p>`,17)]))}const u=s(p,[["render",i]]),o=JSON.parse('{"path":"/frame/vue%E6%A2%B3%E7%90%86.html","title":"vue梳理","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"render","slug":"render","link":"#render","children":[]},{"level":3,"title":"update","slug":"update","link":"#update","children":[]},{"level":3,"title":"首次渲染和更新","slug":"首次渲染和更新","link":"#首次渲染和更新","children":[]},{"level":3,"title":"编译","slug":"编译","link":"#编译","children":[]},{"level":3,"title":"nextTick","slug":"nexttick","link":"#nexttick","children":[]},{"level":3,"title":"Vue.set","slug":"vue-set","link":"#vue-set","children":[]}],"git":{"updatedTime":1628756554000,"contributors":[{"name":"wuhui","username":"wuhui","email":"maniwu@aijiatui.com","commits":1,"url":"https://github.com/wuhui"}],"changelog":[{"hash":"d26e4a13cfeb6929ab0592e823d92e4a930fc261","time":1628756554000,"email":"maniwu@aijiatui.com","author":"wuhui","message":"up"}]},"filePathRelative":"frame/vue梳理.md"}');export{u as comp,o as data};
